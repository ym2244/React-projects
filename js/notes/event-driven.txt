fetch("https://example.com") // è¿”å›žçš„æ˜¯ Promise
  .then((response) => {
    // ä¸è®ºæ˜¯ 200 è¿˜æ˜¯ 404ï¼Œåªè¦èƒ½è¿žä¸ŠæœåŠ¡å™¨ï¼Œå°±æ˜¯ resolve çŠ¶æ€
    if (!response.ok) {
      throw new Error("HTTP é”™è¯¯çŠ¶æ€ç : " + response.status);
    }
    return response.json();
  })
  .catch((err) => {
    console.log("è¯·æ±‚å¤±è´¥:", err);
  })
  .finally(() => {
    console.log("fetch è¯·æ±‚å®Œæ¯•");
  });

ä¸è®ºæ˜¯è‡ªå·±å†™çš„ Promise å¯¹è±¡ï¼Œè¿˜æ˜¯åƒ fetch() è¿™ç§åŸºäºŽ Promise çš„ APIï¼Œåªè¦å¼‚æ­¥æ“ä½œæˆåŠŸäº†ï¼Œ
Promise å°±ä¼šè¿›å…¥ resolved çŠ¶æ€å¹¶è§¦å‘ .then()ï¼›
å¦‚æžœå¤±è´¥åˆ™è¿›å…¥ rejected çŠ¶æ€å¹¶è§¦å‘ .catch()ï¼›
æ— è®ºæˆåŠŸä¸Žå¦ï¼Œ.finally() éƒ½ä¼šæ‰§è¡Œä¸€æ¬¡ã€‚
å¦‚æžœåœ¨ .then() æˆåŠŸä¹‹åŽæŽ¥äº† .catch()ï¼Œåªè¦æ²¡æœ‰é”™è¯¯ï¼Œ.catch() æ˜¯ä¸ä¼šæ‰§è¡Œçš„ã€‚


Promise æœ‰ä¸‰ç§çŠ¶æ€ï¼š
pendingï¼ˆè¿›è¡Œä¸­ï¼‰
fulfilledï¼ˆå·²æˆåŠŸ â†’ resolveï¼‰
rejectedï¼ˆå·²å¤±è´¥ â†’ rejectï¼‰


ðŸ”— æ–¹æ³•å¯¹åº”çŠ¶æ€å’Œè§¦å‘æ¡ä»¶
æ–¹æ³•	çŠ¶æ€	è§¦å‘æ¡ä»¶
.then()	fulfilled	åªæœ‰åœ¨ Promise æˆåŠŸï¼ˆresolveï¼‰åŽæ‰§è¡Œ
.catch()	rejected	åªæœ‰åœ¨ Promise å¤±è´¥ï¼ˆrejectï¼‰åŽæ‰§è¡Œ
.finally()	ä¸è®ºæˆè´¥	æ— è®ºæ˜¯ resolve è¿˜æ˜¯ reject éƒ½ä¼šæ‰§è¡Œ



htmlä¸­çš„classæ˜¯ä¸€ä¸ªæ ‡ç­¾ï¼Œç”¨æ¥
-  CSS é€‰æ‹©å™¨ - æ ·å¼æŒ‚é’©
-  JS æŸ¥è¯¢ - DOM æ“ä½œå…¥å£
- åˆ†ç»„å¤ç”¨ - å¤šä¸ªå…ƒç´ ç”¨åŒä¸€ä¸ªclass, æ ·å¼/è¡Œä¸ºç»Ÿä¸€åŒ–


async function on single thread (js)
-> there are call stack, event loop, microtask queue > task queue
- microtask queue: promise, mutation observer, fetch, async/await
- task queue: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O

Promise.resolve() å’Œ Promise.reject()
const p1 = Promise.resolve("æˆåŠŸ");
const p2 = Promise.reject("å¤±è´¥");


addEventListener("click", (e) => {
  console.log("ç‚¹å‡»äº†æŒ‰é’®");
  // è¿™é‡Œçš„ this æ˜¯ window
  console.log(this); // window
});

bubbling ç”¨æ¥åš delegation
event flowï¼š
- capture: äº‹ä»¶ä»Ž window -> document -> target
- Target Phase: äº‹ä»¶åœ¨ç›®æ ‡å…ƒç´ ä¸Šè§¦å‘
- bubbling: äº‹ä»¶ä»Ž target -> document -> window


event-driven
1. event loop: handling queues
2. compared to message driven 
3. how promise works -- the order of tasks going to the queue -- promise always return a promise
4. event bubbling and capturing
5. addEventListener syntax -- use 4.
6. fetch API syntax -- trigered by event 